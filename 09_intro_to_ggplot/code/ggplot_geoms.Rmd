---
title: "Tidybiology Tiny Lectures: ggplot "
subtitle: "ggplot: geoms"
author: "Matthew Hirschey, Ph.D."
date: "April 2020"
output: 
  ioslides_presentation:
    widescreen: true
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(knitr)
library(here)
library(rlang)
library(patchwork)
library(ggrepel)
knitr::opts_chunk$set(echo = FALSE, 
                      fig.align="center")
source(here::here("code", "bespoke.R")) #loads custom objects
```

## How are these two plots similar?
```{r double_plot, echo = FALSE, message=FALSE, warning=FALSE}
plot1 <- df_input %>% 
  ggplot(aes(!!sym(df_numeric1_name), !!sym(df_numeric2_name))) +
  geom_point() 

plot2 <- df_input %>% 
  ggplot(aes(!!sym(df_numeric1_name), !!sym(df_numeric2_name))) +
  geom_smooth() 

plot1 + plot2
```

## The `geom` is different between these plots
`geom` is short for geometric object, which is the visual object used to represent the data  
    
`plot1 <- ggplot(`r dataframe_name`) +`  
  `geom_point(aes(`r df_numeric1_name`, `r df_numeric2_name`))`   
  
`plot2 <-  ggplot(`r df_numeric1_name`, `r df_numeric2_name`) +`  
  `geom_smooth(aes(`r df_numeric1_name`, `r df_numeric2_name`))`   

## Choosing your (geom)itries
Different data types require different plot types.  
  
When plotting your data, it is often helpful to take a glimpse at the data you intend to plot to know what kinds of variables you will be working with

`glimpse(`r dataframe_name`)`
```{r glimpse_again, exercise=TRUE}

```

## Geoms 
So now that you know your variable types, how do you know what geoms to use??  
  
Use the following resources to match your data type to the appropriate `geoms`

----
<a href="https://rstudio.com/resources/cheatsheets" target="_blank">https://rstudio.com/resources/cheatsheets/</a><br>
<center><iframe src="https://rstudio.com/resources/cheatsheets"></iframe></center>

----
<a href="https://www.data-to-viz.com/" target="_blank">https://www.data-to-viz.com/</a><br>
<center><iframe src="https://www.data-to-viz.com/"></iframe></center>

## Change this scatterplot code to draw boxplots {.smaller} 
`ggplot(`r dataframe_name`) + geom_point(aes(x=`r df_char1_name`,y=`r df_numeric1_name`))`  
```{r boxplot_activity, exercise = TRUE}

```
  
Use the cheatsheet. Try your best guess.  

## What will this code do?
  
`ggplot(`r dataframe_name`) +`   
`geom_boxplot(aes(x=`r df_char1_name`,y=`r df_numeric1_name`)) +`  
`geom_point(aes(x=`r df_char1_name`,y=`r df_numeric1_name`))`  

## Try including two `geoms` for yourself
```{r 2geom_activity, exercise = TRUE}

```
  
**Each new geom adds a new layer**  

## Aesthetics
Everything up to this point gets you a basic graph; but what about colors, shapes and overall style?  
  
You can change 5 basic aesthetics  
1. **Color**- changes the outline color of your datapoints  
2. **Size** - choose the size of the datapoint  
3. **Shape** - choose a pre-defined shape  
4. **Alpha**- changes the transparency of each point  
5. **Fill**- changes the fill color of your points  
  
Go to code/  
Open 04_ggplot2.Rmd  
Complete the exercise.    
  
## Mapping these aesthetics to data
Beyond simply changing the size or color of the variables in your plot, you can encode more information by mapping these values to data in your data set.  
  
Go to code/  
Open 05_aes.Rmd  
Complete the exercise.  
  
## Global vs Local {.build}
In ggplot2, we have the options to set mappings globally or locally. Setting a mapping globally means to set those values in the original ggplot function.  
  
Example: Earlier in class you made this graph:

`ggplot(`r dataframe_name`) +`  
  `geom_jitter(aes(x=`r df_char1_name`, y=`r df_numeric1_name`))+`  
  `geom_boxplot(aes(x=`r df_char1_name`, y=`r df_numeric1_name`))`  
  
## Global vs Local
```{r global_v_local_concepts, echo = FALSE, warning = FALSE}
ggplot(df_input) +
  geom_jitter(aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_boxplot(aes(!!sym(df_char1_name), !!sym(df_numeric1_name)))
```

## Global vs Local
However, if we map our x and y values in the ggplot function we find that we generate the same graph  
  
`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot()`  
```{r global_v_local, echo = FALSE, warning = FALSE}
ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot()
```

## Global vs Local {.build}
This is because when you set the aes mappings in the original `ggplot` function you are setting the `aes` **globally**.  
This means all the functions afterwards will inherit that mapping. So in our example, this means that both the jitter and boxplot geoms know to graph the same information  
  
You can also set aes values **locally** within the geom function. Doing so will only change the values in that geom

## Global vs Local
`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot(aes(color = `r df_char1_name`))`      
```{r global_v_local1, echo = FALSE, warning = FALSE}
ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot(aes(color = !!sym(df_char1_name)))
```

## Global vs Local {.build}
```{r global_v_local2, echo=FALSE}
mean <- mean(df_numeric2_vec)
sd <- sd(df_numeric2_vec)
```

Data can also be set locally or globally. For this example, let's filter our original data first using the `dplyr::filter` function
  
`df_filter <- `r dataframe_name` %>% filter(`r df_numeric2_name` > `r round(mean + 2*sd)`)`  
  
*this number is two standard deviations above the `mean` value of `r df_numeric2_name`

## Global vs Local {.build}
Now, let's identify only the `r dataframe_about` in our data that are outliers, more than 2SD above the mean, by setting data locally in a new geom  
  
`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot(aes(color = `r df_char1_name`)) +`   
`geom_label(data=df_filter, aes(label=`r df_id_name`))`  

## Global vs Local {.build}
```{r global_v_local3, echo = FALSE, warning = FALSE}
df_filter <- df_input %>% filter(!!sym(df_numeric2_name) > round(mean + 2*sd))

ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot(aes(color = !!sym(df_char1_name))) +
  geom_label_repel(data = df_filter, aes(label = !!sym(df_id_name)))
```

## Global vs Local {.build}
You notice we have to indicate the new dataset, but because it has the same x and y values, we did not need to set those mappings  
  
Go to code/  
Open 06_global_v_local.Rmd  
Complete the exercise to practice mapping locally and globally.   

## Labels and Legends
Several options exist to change the default labels and legends. Recall, this code:  
  
`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot(aes(color = `r df_char1_name`))`   

## Labels and Legends {.build}
```{r labs, echo = FALSE, warning = FALSE}
original_plot <- ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot(aes(color = !!sym(df_char1_name)))
original_plot
```
  
But it has two problems:  
1. The x-axis label is redundant  
2. The figure legend is also redundant  

## Change labels using `labs`
`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot(aes(color = `r df_char1_name`)) +`  
`labs(x ="") #blank quotes removes the label`

## Change labels using `labs`
Gave us this plot:  
```{r labs_fix, echo = FALSE, warning = FALSE}
ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot(aes(color = !!sym(df_char1_name))) +
  labs(x = "")
```

## Change legend using `guides`
`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot(aes(color = `r df_char1_name`)) +`  
`labs(x ="") #blank quotes removes the label +`  
`guides(color = "none")`

## Change legend using `guides` 
```{r guides, echo = FALSE, warning = FALSE}
lab_plot <- ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot(aes(color = !!sym(df_char1_name))) +
  labs(x = "") + 
  guides(color = "none")
original_plot + lab_plot
```

## Faceting {.build}
Faceting allows you to create multiple graphs side by side in one panel. Especially useful when you want to see the data together, but not on top of each other  
  
For example:  
  
`ggplot(`r dataframe_name`) +`  
`geom_point(aes(x=`r df_char1_name`, y=`r df_numeric1_name`)) +`  
`facet_grid(cols = vars(`r df_char2_name`))`

## Faceting
```{r facetting, echo = FALSE, warning = FALSE}
ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_point() +
  facet_grid(cols = vars(!!sym(df_char2_name)))
```
  
*This is especially useful for exploratory data analysis

## Themes {.build}
You can change almost everything you see on your chart, but a lot of the things you may look to change are part of the "theme"  
  
Here we are going to change some features about our title text:  
  
`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot(aes(color = `r df_char1_name`)) +`  
`labs(title = "My first plot") +`  
`theme(plot.title = element_text(face = "bold", size = 12))` 

## Themes {.build}
```{r themes, echo = FALSE, warning = FALSE}
theme1 <- ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot(aes(color = !!sym(df_char1_name))) +
  labs(title = "My first plot") +
  theme(plot.title = element_text(face = "bold", size = 12)) 
original_plot + theme1
```

## Themes {.build}
Next, let's change the aesthetics of our legend box  
  
`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot(aes(color = `r df_char1_name`)) +`  
`labs(title = "My first plot") +`  
`theme(plot.title = element_text(face = "bold", size = 12),`  
`legend.background = element_rect(fill="gray", colour="black"))`   

## Themes {.build}
```{r themes2, echo = FALSE, warning = FALSE}
theme2 <- ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot(aes(color = !!sym(df_char1_name))) +
  labs(title = "My first plot") +
  theme(plot.title = element_text(face = "bold", size = 12), 
        legend.background = element_rect(fill="gray", colour="black")
  ) 
theme1 + theme2
```

## Themes {.build}
Finally, let's change the legend position  
  
`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot(aes(color = `r df_char1_name`)) +`  
`labs(title = "My first plot") +`  
`theme(plot.title = element_text(face = "bold", size = 12),`  
`legend.background = element_rect(fill="gray", colour="black"),`  
`legend.position = "bottom"))` 

## Themes {.build}
```{r themes3, echo = FALSE, warning = FALSE}
theme3 <- ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot(aes(color = !!sym(df_char1_name))) +
  labs(title = "My first plot") +
  theme(plot.title = element_text(face = "bold", size = 12), 
        legend.background = element_rect(fill="gray", colour="black"),
        legend.position = "bottom"
  ) 
theme2 + theme3
```

## Themes {.build}
Pre-set themes also exist as an easy way to change the entire theme of your graph quickly. They can also be combined with custom theme settings  

`ggplot(`r dataframe_name`, aes(x=`r df_char1_name`, y=`r df_numeric1_name`) +`  
`geom_jitter() +`    
`geom_boxplot(aes(color = `r df_char1_name`)) +`  
`labs(title = "My first plot") +`  
`theme_minimal()`  

## Themes {.build}
```{r themes4, echo = FALSE, warning = FALSE}
theme4 <- ggplot(df_input, aes(!!sym(df_char1_name), !!sym(df_numeric1_name))) +
  geom_jitter() +
  geom_boxplot(aes(color = !!sym(df_char1_name))) +
  labs(title = "My first plot") +
  theme_minimal()
theme1 + theme4
```

## Saving plots using `ggsave` {.build}

If you make a plot there are a few ways to save it, though the simplest is to use `ggsave`  

`ggsave("ggsaveexample.png", plot = last_plot())`  

You can change the type of file you save or the size.  
  
`ggsave("ggsaveexample.pdf", plot = my_awesome_object, width = 6, height = 6, units = "cm")`  

## Saving plots using ggsave
Where does it save??  
  
`getwd()`